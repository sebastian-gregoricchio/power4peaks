#' @title get.stats
#'
#' @description Extract statistics and degrees of freedom from a DiffBind object (class \code{DBA}).
#'
#' @param dba.object An object of class \code{DBA} obtained from DiffBind.
#' @param contrast Vector of 3-elements indicating (in order): metadata_column, group_1, group_2.
#' @param design String indicating the design to use in the differential analyses.
#' @param diff.method String indicating which tool to use to perform differential analyses. One among: 'DESeq2' and 'edgeR'. Default: \code{"DESeq2"}.
#' @param p.adjust.method String indicating the method to use to correct the p-values. One among: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none". Default: \code{BH}.
#'
#' @return An object of class \code{power4peaks.stats}.

#' @export get.stats


get.stats =
  function(dba.object,
           contrast,
           design,
           diff.method = "DESeq2",
           p.adjust.method = "BH") {

    ### Libraries
    require(dplyr)
    # require(DiffBind)
    # require(edgeR)
    # require(DESeq2)


    ## verify object
    if (!("DBA" %in% class(dba.object))) {
      warning("The input must be an object of class 'DBA', as generated by diffBind.")
      return()
    }

    ## Convert design to character
    design = paste0(as.character(design), collapse = "")


    ## check contrast
    meta = dba.object$samples

    if (!(contrast[1] %in% colnames(meta))) {
      warning(paste0("The variable `", contrast[1], "` indicated in the contrast is not available, choose one among:\n",
                     paste0(colnames(meta)[!(colnames(meta) %in% c("SampleID", "bamReads", "bamControl", "Peaks", "PeakCaller"))], collapse = ", "),"."))
      return()
    } else if (!(contrast[2] %in% meta[,contrast[1]])) {
      warning(paste0("The element `", contrast[2], "` indicated in the contrast is not available for the variable '",contrast[1],
                     "`, choose one among:\n", paste0(unique(meta[,contrast[1]]), collapse = ", "),"."))
      return()
    } else if (!(contrast[3] %in% meta[,contrast[1]])) {
      warning(paste0("The element `", contrast[3], "` indicated in the contrast is not available for the variable '",contrast[1],
                     "`, choose one among:\n", paste0(unique(meta[,contrast[1]]), collapse = ", "),"."))
      return()
    } else {
      rownames(meta) = meta$SampleID
    }



    ### Collect and clean counts
    counts =
      as.data.frame(dba.object$binding) %>%
      dplyr::mutate(peak_id = paste(CHR, START, END, sep = "_"))

    rownames(counts) = counts$peak_id
    counts = dplyr::select(.data = counts, -CHR, -START, -END, -peak_id)




    ############# DIFF ANALYSES
    ### DESeq2
    if (tolower(diff.method) %in% c("deseq", "des", "deseq2", "dds")) {
      require(DESeq2)

      ### Load in DESeq2 and Estimate size factors from diffBind
      dba.object_norm = DiffBind::dba.normalize(dba.object, method = DiffBind::DBA_DESEQ2)


      dds = suppressMessages(suppressWarnings(DESeqDataSetFromMatrix(countData = round(as.matrix(counts)),
                                                                     colData = meta,
                                                                     design = as.formula(design))))

      dds = estimateSizeFactors(dds)

      ## Reset original counts and sizeFactors from diffBind
      dds@colData$sizeFactor = dba.object_norm$norm$DESeq2$norm.facs


      ## Apply model
      dds = DESeq(dds, fitType = "local")


      ### Collect values for output slots
      diff.object = dds
      results = results(dds, contrast = contrast, pAdjustMethod = p.adjust.method)
      design_matrix = model.matrix(object = design(dds), data = colData(dds))
      df1 = ncol(design_matrix)
      df2 = NULL
      statistics = results$stat
      stat.distribution = "norm"
      method = "DESeq2"

    } else {


      ############################################
      ### edgeR
      require(edgeR)

      # Estimate size factors from diffBind
      #dba.object_norm = DiffBind::dba.normalize(dba.object, method = DBA_EDGER)

      # Load counts in edgeR
      groups = factor(meta[,contrast[1]])
      DGE_list = DGEList(counts = counts, group = groups)

      # Make design matrix
      design_edgeR = model.matrix(object = as.formula(paste0("~ 0 + ",contrast[1])), data = meta)
      colnames(design_edgeR) = levels(groups)

      # Make contrast
      contrast_A_vs_B = makeContrasts(contrasts = paste(contrast[2],"-",contrast[3]), levels = design_edgeR)

      # Compute normalization
      DGE_list = calcNormFactors(DGE_list)

      # Estimate dispersion
      DGE_list = estimateDisp(DGE_list, design = design_edgeR)

      # Fit a generalized linear model (GLM) with quasi-likelihood methods
      fit = glmQLFit(y = DGE_list, design = design_edgeR)
      test = glmQLFTest(glmfit = fit, contrast = contrast_A_vs_B, coef = 2)


      ### Collect values for output slots
      diff.object = list(DGE_list = DGE_list,
                         contrast_A_vs_B = contrast_A_vs_B,
                         glmQLFit = fit,
                         glmQLFit.test = test)
      design_matrix = design_edgeR
      df1 = 1
      df2 = median(test$df.total)
      results = as.data.frame(topTags(object = test, n = nrow(counts), adjust.method = p.adjust.method))
      statistics = results$`F`
      method = "edgeR"
      stat.distribution = "f"
    }



    ####### Export results
    power4peaks.stats =
      new(Class = "power4peaks.stats",
          dba.object = dba.object,
          contrast = contrast,
          design = design_matrix,
          diff.method = method,
          p.adjust.method = p.adjust.method,
          diff.object = diff.object,
          results = results,
          statistics = statistics,
          stat.distribution = stat.distribution,
          df = df)

    return(power4peaks.stats)
  } # END function
