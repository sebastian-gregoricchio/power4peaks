#' @title compute.power
#'
#' @description Compute the power and effect size for the object obtained from \link{get.stats}.
#'
#' @param power4peaks.stats An object of class \code{power4peaks.stats}.
#' @param sample.size.range Numeric vector of length 2, indicating minimum and maximum of the range of number of samples in which test the power. Default: \code{c(0,50)}.
#' @param power.threshold number between 0 and 1 indicating the threshold to plot for the power. Default: \code{0.8} (80 percent power).
#' @param distribution.type String indicating the type of distribution to use; one among: 'norm', 't', 'f', 'chisq'. Default: \code{NULL}, automatically defined from the power4peaks.stats object.
#' @param df Numeric value or vector (df1 and df2, only for F statistics) indicating the number of degrees of freedom. Default: \code{NULL}, automatically defined from the power4peaks.stats object.
#'
#' @return An object of class \code{power4peaks.power}.

#' @export compute.power


compute.power =
  function(power4peaks.stats,
           sample.size.range = c(0, 50),
           power.threshold = 0.8,
           distribution.type = NULL,
           df = NULL) {

    ### libraries
    # SSPA installation
    if (!requireNamespace("SSPA", quietly = TRUE)) {
      warning("The 'SSPA' (Bioconductor) package must be installed to use this function.")

      ### Ask for installing
      install = readline("Do you want to install `SSPA`? [yes/no] ")
      if (tolower(install) %in% c("yes","y","yeah","yep","yo","ya")) {
        install.packages("https://www.bioconductor.org/packages/3.12/bioc/src/contrib/SSPA_2.30.0.tar.gz", type = "source")
        library(SSPA)
      }
    } else {
      require(SSPA)
    }



    ### Check object
    if (!("power4peaks.stats" %in% class(power4peaks.stats))) {
      warning("The 'power4peaks.stats' object must be of class power4peaks.stats, as generated by `get.stats` or `as.power4peaks` function.")
      return()
    }



    ########
    ## define SSPA parameters
    if (is.null(distribution.type)) {
      distribution.type = power4peaks.stats@stat.distribution
    } else {
      if (!(tolower(distribution.type) %in% c("norm", "t", "f", "chisq"))){
        warning("The distribution.type must be one among: 'norm', 't', 'f', 'chisq'.")
        return()
      } else {
        distribution.type = tolower(distribution.type)
      }
    }


    if (is.null(df)) {
      if (!is.null(power4peaks.stats@df2)) {
        df = c(power4peaks.stats@df1, power4peaks.stats@df2)
      } else {
        df = power4peaks.stats@df1
      }
    } else {
      if (tolower(distribution.type) == "f" & length(df) != 2) {
        warning("When distribution.type is F, the df must be a vector of two elements: c(numerator.df1, denominator.df2).")
        return()
      }
    }



    # Run SSPA analyses
    pd = SSPA:::pilotData(statistics = power4peaks.stats@statistics,
                          samplesize = sum(power4peaks.stats@dba.object$samples[,power4peaks.stats@contrast[1]] %in% power4peaks.stats@contrast[2:3]),
                          distribution = distribution.type,
                          df = df)

    ss = SSPA::sampleSize(PilotData = pd,
                          method = "congrad",
                          control = list(from = sample.size.range[1], to = sample.size.range[2]))


    test_sample_sizes = seq(ifelse(sample.size.range[1] < 0, yes = 0, no = sample.size.range[1]), sample.size.range[2], 1)
    pwr = SSPA::predictpower(ss, samplesizes = test_sample_sizes, plot = F)



    ####################################
    ### plotting
    title_lable = ifelse(test = distribution.type == "f",
                         yes = paste0("Method: **", power4peaks.stats@diff.method, "** (*df:* ",df, ")"),
                         no = paste0("Method: **", power4peaks.stats@diff.method, "** (*df1:* ",df[1], ", *df2:* ",df[1],")"))


    effect_size_plot =
      ggplot(data = data.frame(effect_size = ss@theta,
                               Lamba = ss@lambda),
             aes(x = effect_size,
                 y = Lamba)) +
      geom_line() +
      geom_vline(xintercept = sum(power4peaks.stats@dba.object$samples[,power4peaks.stats@contrast[1]] %in% power4peaks.stats@contrast[2:3]), linetype = 3, color = "gray50") +
      xlab("Effect Size (theta)") +
      xlim(c(0,NA)) +
      ggtitle(label = title_lable,
              subtitle = paste0("*",power4peaks.stats@contrast[1],"*: **", power4peaks.stats@contrast[2], "** *vs* **",power4peaks.stats@contrast[3],"**")) +
      ggpubr::theme_pubr() +
      theme(axis.text = element_text(color = "black"),
            axis.ticks = element_line(color = "black"),
            plot.title = ggtext::element_markdown(hjust = 0.5),
            plot.subtitle = ggtext::element_markdown(hjust = 0.5))



    power_plot =
      ggplot(data = data.frame(sample_size = test_sample_sizes,
                               Power = pwr),
             aes(x = sample_size,
                 y = Power)) +
      geom_line(linewidth = 1) +
      xlab("Sample size") +
      theme_classic() +
      geom_vline(xintercept = sum(power4peaks.stats@dba.object$samples[,power4peaks.stats@contrast[1]] %in% power4peaks.stats@contrast[2:3]), linetype = 3, color = "gray50") +
      geom_hline(yintercept = power.threshold, linetype = 1, color = "firebrick") +
      scale_y_continuous(limits = c(0,1), expand = c(0,0)) +
      ggpubr::theme_pubr()



    ### Export object
    power4peaks.power =
      new(Class = "power4peaks.power",
          pilot.data = pd,
          sample.size = ss,
          power = list(test.sample.sizes = test_sample_sizes,
                       power = pwr),
          effect.size.plot = effect_size_plot,
          power.plot = power_plot)

    return(power4peaks.power)

  } # END function
